#!/usr/bin/env bash

# Claude commit helper script
# Ensures signed commits with conventional commit format and emojis
# Supports semantic versioning for releases

set -euo pipefail

# Conventional commit types with emojis
declare -A COMMIT_TYPES=(
    ["feat"]="âœ¨"
    ["fix"]="ğŸ›"
    ["docs"]="ğŸ“"
    ["style"]="ğŸ’„"
    ["refactor"]="â™»ï¸"
    ["perf"]="âš¡"
    ["test"]="âœ…"
    ["build"]="ğŸ‘·"
    ["ci"]="ğŸ’š"
    ["chore"]="ğŸ”§"
    ["revert"]="âª"
    ["security"]="ğŸ”’"
    ["deps"]="â¬†ï¸"
    ["config"]="ğŸ”§"
    ["remove"]="ğŸ”¥"
    ["add"]="â•"
    ["update"]="ğŸ”„"
    ["init"]="ğŸ‰"
    ["release"]="ğŸ”–"
    ["hotfix"]="ğŸš‘"
    ["wip"]="ğŸš§"
)

# Semantic versioning levels
declare -A SEMVER_LEVELS=(
    ["major"]="major"
    ["minor"]="minor" 
    ["patch"]="patch"
)

usage() {
    cat << EOF
Usage: commit [OPTIONS] <type> [scope] <message>

OPTIONS:
    -h, --help          Show this help message
    -t, --tag <level>   Create a semantic version tag (major|minor|patch)
    -p, --push          Push after committing (and tagging if applicable)
    -d, --dry-run       Show what would be committed without executing

COMMIT TYPES:
    feat        âœ¨  New feature
    fix         ğŸ›  Bug fix
    docs        ğŸ“  Documentation changes
    style       ğŸ’„  Code style changes (formatting, etc.)
    refactor    â™»ï¸   Code refactoring
    perf        âš¡  Performance improvements
    test        âœ…  Adding or updating tests
    build       ğŸ‘·  Build system changes
    ci          ğŸ’š  CI/CD changes
    chore       ğŸ”§  Maintenance tasks
    revert      âª  Revert previous commit
    security    ğŸ”’  Security improvements
    deps        â¬†ï¸   Dependency updates
    config      ğŸ”§  Configuration changes
    remove      ğŸ”¥  Remove code or files
    add         â•  Add new dependencies or files
    update      ğŸ”„  Update existing functionality
    init        ğŸ‰  Initial commit
    release     ğŸ”–  Release version
    hotfix      ğŸš‘  Critical hotfix
    wip         ğŸš§  Work in progress

EXAMPLES:
    commit feat "auth" "add JWT authentication"
    commit fix "user-login" "resolve password validation issue"
    commit docs "update README with installation steps"
    commit feat "api" "implement user registration endpoint" --tag minor
    commit chore "update dependencies" --push

SEMANTIC VERSIONING:
    --tag major     Breaking changes (1.0.0 -> 2.0.0)
    --tag minor     New features (1.0.0 -> 1.1.0)
    --tag patch     Bug fixes (1.0.0 -> 1.0.1)
EOF
}

get_next_version() {
    local level="$1"
    
    # Get the latest tag, default to 0.0.0 if none exists
    local current_version
    current_version=$(git describe --tags --abbrev=0 2>/dev/null || echo "0.0.0")
    
    # Remove 'v' prefix if present
    current_version=${current_version#v}
    
    # Split version into components
    IFS='.' read -ra VERSION_PARTS <<< "$current_version"
    local major=${VERSION_PARTS[0]:-0}
    local minor=${VERSION_PARTS[1]:-0}
    local patch=${VERSION_PARTS[2]:-0}
    
    case "$level" in
        "major")
            echo "v$((major + 1)).0.0"
            ;;
        "minor")
            echo "v${major}.$((minor + 1)).0"
            ;;
        "patch")
            echo "v${major}.${minor}.$((patch + 1))"
            ;;
        *)
            echo "Invalid semver level: $level" >&2
            exit 1
            ;;
    esac
}

check_git_config() {
    # Check if git is configured for signing
    if ! git config user.signingkey >/dev/null 2>&1; then
        echo "Warning: No signing key configured. Commits will not be signed." >&2
        echo "Configure with: git config user.signingkey <key-id>" >&2
    fi
    
    # Check if commit signing is enabled
    if [[ "$(git config commit.gpgsign)" != "true" ]]; then
        echo "Warning: GPG signing not enabled. Enable with: git config commit.gpgsign true" >&2
    fi
}

main() {
    local commit_type=""
    local scope=""
    local message=""
    local tag_level=""
    local should_push=false
    local dry_run=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                usage
                exit 0
                ;;
            -t|--tag)
                tag_level="$2"
                if [[ ! "${SEMVER_LEVELS[$tag_level]:-}" ]]; then
                    echo "Error: Invalid semver level '$tag_level'" >&2
                    echo "Valid levels: major, minor, patch" >&2
                    exit 1
                fi
                shift 2
                ;;
            -p|--push)
                should_push=true
                shift
                ;;
            -d|--dry-run)
                dry_run=true
                shift
                ;;
            -*)
                echo "Error: Unknown option $1" >&2
                usage
                exit 1
                ;;
            *)
                if [[ -z "$commit_type" ]]; then
                    commit_type="$1"
                elif [[ -z "$scope" && $# -gt 1 ]]; then
                    # Check if this looks like a scope (next arg exists and current doesn't start with uppercase)
                    if [[ ! "$1" =~ ^[A-Z] ]]; then
                        scope="$1"
                    else
                        message="$1"
                    fi
                elif [[ -z "$message" ]]; then
                    message="$1"
                else
                    message="$message $1"
                fi
                shift
                ;;
        esac
    done
    
    # Validate required arguments
    if [[ -z "$commit_type" ]]; then
        echo "Error: Commit type is required" >&2
        usage
        exit 1
    fi
    
    if [[ -z "$message" ]]; then
        echo "Error: Commit message is required" >&2
        usage
        exit 1
    fi
    
    # Validate commit type
    if [[ ! "${COMMIT_TYPES[$commit_type]:-}" ]]; then
        echo "Error: Invalid commit type '$commit_type'" >&2
        echo "Valid types: ${!COMMIT_TYPES[*]}" >&2
        exit 1
    fi
    
    # Check git configuration
    check_git_config
    
    # Build commit message
    local emoji="${COMMIT_TYPES[$commit_type]}"
    local full_message
    
    if [[ -n "$scope" ]]; then
        full_message="${commit_type}(${scope}): ${emoji} ${message}"
    else
        full_message="${commit_type}: ${emoji} ${message}"
    fi
    
    # Show what will be committed
    echo "Commit message: $full_message"
    
    if [[ "$dry_run" == true ]]; then
        echo "[DRY RUN] Would execute: git commit -S -m \"$full_message\""
        if [[ -n "$tag_level" ]]; then
            local next_version
            next_version=$(get_next_version "$tag_level")
            echo "[DRY RUN] Would create tag: $next_version"
        fi
        if [[ "$should_push" == true ]]; then
            echo "[DRY RUN] Would push to remote"
        fi
        exit 0
    fi
    
    # Commit with signature
    if ! git commit -S -m "$full_message"; then
        echo "Error: Failed to create commit" >&2
        exit 1
    fi
    
    echo "âœ… Commit created successfully"
    
    # Create tag if requested
    if [[ -n "$tag_level" ]]; then
        local next_version
        next_version=$(get_next_version "$tag_level")
        
        echo "Creating tag: $next_version"
        if ! git tag -s "$next_version" -m "Release $next_version"; then
            echo "Error: Failed to create tag" >&2
            exit 1
        fi
        echo "âœ… Tag $next_version created successfully"
    fi
    
    # Push if requested
    if [[ "$should_push" == true ]]; then
        echo "Pushing to remote..."
        if ! git push; then
            echo "Error: Failed to push commits" >&2
            exit 1
        fi
        
        if [[ -n "$tag_level" ]]; then
            if ! git push --tags; then
                echo "Error: Failed to push tags" >&2
                exit 1
            fi
        fi
        echo "âœ… Pushed successfully"
    fi
}

main "$@"